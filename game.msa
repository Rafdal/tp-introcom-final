
	p68h11

	extern waitkey

	extern	shot_ID,coor2,coor1,copiado,play1,play2
	extern	displ,frase2,turno,frase1
	extern	espiral,winner1,winner2
	extern	canhun1,canhun2

	public	setTurn,testWin,inRange

$const.def
$macros.def



**************************************************************************************************
*
*	Subrutina inRange: Comprueba que las coordenadas recibidas por AccA (coor1) y AccB (coor2)
*		   estén dentro de la matriz de jugador.
*		- Recibe por A la coordenada de la fila y por B la coordenada de la columna
*		- Devuelve el bit de Carry en 1 si se encuentrá por fuera del tablero
*			o en 0 si se encuentra dentro de los límites
*
**************************************************************************************************
inRange	equ	*

	%BACKUP
	
	cmpa	#$A		; Comparamos la primera coordenada con la mínima posible
	bmi	afuera		; Si es menor, salimos indicando que no pertenece a la matriz
	cmpa	#$F		; Comparamos la primera coordenada con la mayor posible
	bhi	afuera		; Si es mayor, salimos indicando que no pertenece a la matriz
	cmpb	#1		; Comparamos la segunda coordenada con la mínima posible
	bmi	afuera		; Si es menor, salimos indicando que no pertenece a la matriz
	cmpb	#6		; Comparamos la segunda coordenada con la máxima posible
	bhi	afuera		; Si es mayor, salimos indicando que no pertenece a la matriz
	bra	adentro		; Si no se cumplió ninguna de las condiciones anteriores, las coordenadas
*	...			; son correctas

*	Zona donde las coordenadas recibidas no son válidas
afuera	sec			; Seteamos el carry en 1 indicando que hubo error
	bra	endlim		; Salimos de la subrutina

*	Zona donde las coordenadas recibidas son válidas
adentro	clc			; Seteamos el carry en 0 indicando que no hubo error

endlim	%RESTORE
	rts



***************************************************************************************************************
*
*	testWin: Evalúa si uno de los jugadores ganó la partida, y en caso de ganar, procede a indicarlo en el 
*		 display y en el bitmap.
*		- Utiliza como parámetros las variables definidas al final del programa, que evalúan la cantidad
*			de barcos hundidos de cada jugador
*		- Devuelve el bit de Carry en 1 si hubo ganador, y en 0 si no hubo ganador aún.
*
***************************************************************************************************************
testWin	equ	*

	%BACKUP

	ldaa	canhun1
	cmpa	#CAN_BAR	; Comparo la cantidad de hundidos por los jugadores con #6 --> por ser el número de barcos 
	beq	win1		; con los que se juega
	ldaa	canhun2		; Si la cantidad de hundidos por el jugador 1 es 6, imprimimos la frase de felicitaciones al jugador 1
	cmpa	#CAN_BAR	; Si la cantidad de hundidos por el jugador 2 es 6,
	beq	win2		; Imprimimos la frase de felicitaciones al jugador 2
	clc			; ponemos el carry en 0 si ningún jugador ganó.
	bra	finwin		; Si ninguno de los jugadores alcanzó la cantidad de hundidos necesarios, salimos

win1	equ	*
	ldx	#winner1	; Cargamos en X la posición del primer caracter de la frase para el jugador 1
	jsr	displ		; Imprimimos la frase y salimos
	bra	fingana
	
win2	equ	*	
	ldx	#winner2	; Cargamos en X la posición del primer caracter de la frase para el jugador 2
	jsr	displ		; Imprimimos la frase y salimos

fingana	jsr	espiral		; Imprimimos un efecto de espiral en el bitmap mostrando el jugador que ganó la partida
	sec			; ponemos el carry en 1 indicando que un jugador ya ganó y salimos

again	jsr	waitkey		; analizamos el teclado, esperando un RESET
	cmpa	#RESET			
	bne	again		; de ser reset, volvemos a empezar de 0.
	
finwin	%RESTORE


	rts




*************************************************************************************************************
*
*	setTurn: cambia el turno al jugador correspondiente
*		- Recibe por AccA la tecla presionada
*		- Modifica la posición de memoria turno que contiene el turno actual.
*
**************************************************************************************************************
setTurn	equ	*

	%BACKUP

	ldab	turno		; analizamos de quién es el turno que apretó la tecla
	cmpb	#1
	bne	jug2
*_____________________
*
* Turno jugador 1
*____________________
jug1	ldab	shot_ID
	cmpb	#1
	beq	fire1		; analizamos si hubo un disparo previo errado
	cmpa	#P1_KEY		; analizo si la tecla apretada es P1_KEY
	beq	tec1		; si es, se vuelve a elegir el jugador 1
	bra	finturn		; si se apretó P2, salimos (no pasa nada)

fire1	cmpa	#P2		; si hubo disparo y se apretó P2
	beq	tec2		; cambiamos el turno al jugador 2
	bra	finturn		; en caso contrario, salimos (no se repite el turno de P1)
*____________________
*
* Turno jugador 2
*____________________
jug2	ldab	shot_ID
	cmpb	#1
	beq	fire2		; analizamos si hubo un disparo previo errado
	cmpa	#P2		; analizo si la tecla apretada es P2
	beq	tec2		; si es, se vuelve a elegir el jugador 2
	bra	finturn		; si se apretó P1_KEY, salimos (no pasa nada)

fire2	cmpa	#P1_KEY		; si hubo disparo y se apretó P1_KEY
	beq	tec1		; cambiamos el turno al jugador 1
	bra	finturn		; en caso contrario, salimos (no se repite el turno de P2)

*_______________________
*
* Cambio a jugador 1
*_______________________
tec1	ldaa	#1
	staa	turno		; Indico en una posición de memoria que es el turno del jugador 1
	ldx	#frase1		; mostramos la frase de jugador 1 en el display
	jsr	displ
	ldx	#play2		; cargamos en el bitmap el tablero del jugador 2
	bra	change
*_______________________
*
* Cambio a jugador 2
*_______________________
tec2	ldaa	#2
	staa	turno		; Indico en una posición de memoria que es el turno del jugador 2
	ldx	#frase2		; mostramos la frase de jugador 2
	jsr	displ
	ldx	#play1		; cargamos en el bitmap el tablero del jugador 1
*_______________________________________________________________________________
*
* Copiamos la matriz del jugador siguiente y borramos las coordenadas ingresadas
*________________________________________________________________________________
change	jsr	copiado
	clr	coor1
	clr	coor2
	clr	shot_ID

finturn	%RESTORE
	
	rts










	END