
	p68h11

	extern	waitkey,delay

	extern	shot_ID,coor2,coor1,copiado,reveal,play1,play2
	extern	displ,frase2,turno,frase1,outchar,clrdis,clr_tab
	extern	espiral,winner1,winner2
	extern	canhun1,canhun2

	public	setTurn,setCoor,testWin,inRange,ld_Tabs

$const.def
$macros.def
********** DISPL HANDLER ************
	macro	%displ
	pshx
	ldx	#\0
	jsr	displ
	pulx
	endmac
*************************************


	rseg	CODE

ld_Tabs	equ	*

	%displ	frase1
	ldaa	#1
	ldx	#play1
	jsr	ldFleet		Cargamos la flota del player 1
	bcs	retLDT

	%displ	frase2
	ldaa	#2
	ldx	#play2
	jsr	ldFleet		Cargamos la flota del player 2
	bcs	retLDT

	%displ	gamebeg		mensaje de inicio de juego
retLDT	rts




*******************************
*	LOAD FLEET
* AccA:	turno (player_id)		1|2
* AccX: player_table (address)		play1|play2
ldFleet	equ	*
	jsr	clr_tab
	staa	turno
	jsr	reveal		mostramos las ubicaciones de los barcos

	%displ	acz_txt
	ldaa	#3
	ldab	#ACZ
	jsr	ld_ship
	bcs	retFlt

	%displ	car_txt
	ldaa	#2
	ldab	#CAR
	jsr	ld_ship
	bcs	retFlt

	%displ	car_txt
	ldaa	#2
	ldab	#CAR
	jsr	ld_ship
	bcs	retFlt

	%displ	sub_txt
	ldaa	#3
	ldab	#SUB
	jsr	ld_ship
	bcs	retFlt

	jsr	delay		delay para que se vea el barco agregado
retFlt	rts



******************************
*	LOAD SHIP
* AccA: n_blocks
* AccB: ship_id
ld_ship	equ	*
	jsr	clrdis
	jsr	ld_bloc		Cargo el bloque de barco
	bcs	ret_ls		salgo con C=1 para resetear
	jsr	reveal		mostramos las ubicaciones de los barcos
	deca
	bne	ld_ship
ret_ls	rts


********************************
*	LOAD	BLOCK
* AccB: ship_id
ld_bloc	equ	*
	psha
wait	jsr	waitkey		espero a que se presione una tecla
	jsr	shipKey		analizo la tecla presionada
	bcs	ret_bq
	bvc	wait		si V=0, entonces aun no se presiono Fire
	clr	coor1
	clr	coor2
ret_bq	pula
	rts


**************************************************************************************************************
* 
*	shipKey: evalúa qué tecla se apretó y a qué hacer según la tecla presionada.
*		- Recibe por A el valor numérico de la tecla presionada en el teclado, y utiliza
*			las equivalencias definidas como constantes al principio para poder indentificar la tecla.
*		- Devuelve el carry en 1 si se confirmó el RESET, o en 0 si no hubo RESET.
* 
***************************************************************************************************************
shipKey	equ	*

	%BACKUP			; Hago backup de los registros

************ TEST FOR RESET **********
	cmpa	#RESET		; analizamos si la tecla preisonada fue RESET
	bne	not_rst
	sev
	sec
	bra	ret		; si fue, salimos con carry y con overflow

*********** TEST FOR P1 KEY *********
not_rst	cmpa	#P1_KEY		; analizamos si la tecla presionada fue P1_KEY
	clv
	beq	ret_C0		; salimos

*********** TEST FOR P2 KEY *********
	cmpa	#P2		; analizamos si la tecla preisonada fue P2
	clv
	beq	ret_C0		; si fue, salimos

*********** TEST FOR FIRE KEY *********
	cmpa	#FIREKEY	; analizamos si la tecla preisonada fue FIREKEY
	bne	no_fire
	ldaa	coor1
	beq	ret_C0
	ldaa	coor2
	beq	ret_C0
	jsr	setShip		; recibe por AccB el tipo de barco y lo coloca en la posicion
	sev			; a la que apuntan las coordenadas. Coloco V=1
	bra	ret_C0		; salimos

*********** SET COORDINATES **************
no_fire	jsr	setCoor		; si no fue ningun comando, entonces fue una tecla de coordenadas
	clv

ret_C0	clc			; pongo el carry en 0 indicando que no hubo reset

ret	equ	*

	%RESTORE		; Restauro los registros que guardé al comienzo

	rts







*********************************************************************************************
*	Subrutina setShip: Se la llama cuando un jugador presiona FIREKEY! para colocar un barco
*			en las coordenadas ingresadas
*		Modifica una celda de la matriz del jugador actual
*	- Recibe por coor1 y coor2 (variables) las coordenadas a las que se apuntó
*	- Recibe por AccB el tipo de barco y lo coloca en la posicion
**********************************************************************************************
setShip	equ	*
	%BACKUP
	
	ldaa	turno		; Evaluamos el turno del jugador
	cmpa	#1		; y posicionamos X en el tablero del jugador actual
	beq	player1

player2	equ	*
	ldx	#play2		
	bra	set_s
	
player1	equ	*
	ldx	#play1	
		
set_s	equ	*
	pshb			; guardo en stack el tipo de barco

	ldaa	coor1
	ldab	#$A		; Hago que la coordenada 1 pase a ser un número de 0 a 5
	sba			; restandole la menor coordenada posible
	ldab	#COL*EL_SIZE	
	mul	
	abx			; Me posiciono en la fila correspondiente a la coordenada 1
	ldab	coor2
	decb			; Hacemos que AccB contenga al número de columna ingresado
	abx			; "Desplazamos" a X sobre las columnas para llegar a la celda solicitada
*	...			; En este punto X apunta a la celda disparada

	pulb			; recupero el tipo de barco
	stab	0,X		; y lo guardo en la posicion

	%RESTORE
	rts






*==================================================================================
*-	D O C U M E N T A R   M E J O R !!!! 	NO ENTENDI COMO FUNCIONA ESTO
***************************************************************************************************************
*	Subrutina "setCoor": Guarda en posiciones de memoria distintas las coordenadas ingresadas en el teclado
*		- Recibe por AccA el valor de la tecla presionada (valor original del teclado)
*		- Asigna a la tecla presionada un nuevo valor y la guarda en la posición de memoria correspondiente
*		- Devuelve por posiciones de memoria establecidas en el main el valor de la coordenada presionada.
***************************************************************************************************************
setCoor	equ	*
	
	%BACKUP			; Hago backup de todos los registros
	
	cmpa	#$6		; Comparo con 6 (número más alto en la tabla de equivalencias)
	bhi	numero		; para saber si es un Número o una letra

	ldab	coor1		; Si la coordenada ingresada ya tiene algo, salgo para no sobreescribirla
* bne	ret_sc

	cmpa	#$2		; Como las asignaciones de teclas no son consecutivas, debemos evaluar a qué 
	bhi	L04		; segmento pertenece.

******** SEGMENT 1 **********
	ldab	#$A		; convertimos la tecla apretada en el número de fila
	aba			; Realizo una operación con el valor correspondiente al segmento al que pertenece
	staa	coor1		; Como es una letra, la guardamos en la coordenada 1
	bra	prt_let		; Luego de guardar la coordenada, salgo

L04	ldab	#$9		; convertimos la tecla apretada en el número de fila
	aba			
	staa	coor1		; la guardamos en la coordenada 1

prt_let	equ	*
	ldab	#55		; convertimos la letra presionada a caracter ASCII
	aba
	ldab	#1		; la imprimimos en el display
	jsr	outchar
	bra	ret_sc		; salimos


*____________________________
*
* Si es un número (columna)
*____________________________

numero	ldab	coor2		; Si la coordenada ingresada ya tiene algo, salgo para no sobreescribirla
* bne	ret_sc
	
	cmpa	#$A		; Como las asignaciones de teclas no son consecutivas, debemos evaluar a qué
	bhi	L06		; segmento pertenece.

L05	ldab	#7		; convertimos el valor del teclado al valor numérico de la columna
	sba
	staa	coor2		; lo guardamos en la coordenada 2
	bra	prt_num
	
L06	ldab	#8		; convertimos el valor del teclado al valor numérico de la columna
	sba	
	staa	coor2		; lo guardamos en la coordenada 2

prt_num	equ	*
	ldab	#$30		; convertimos el número a su carácter ASCII
	aba
	clrb
	jsr	outchar		; lo imprimimos en la posición de más a la derecha del display
	
ret_sc	equ	*
	
	%RESTORE		; Restauro los registros

	rts			; Salimos de la subrutina







**************************************************************************************************
*
*	Subrutina inRange: Comprueba que las coordenadas recibidas por AccA (coor1) y AccB (coor2)
*		   estén dentro de la matriz de jugador.
*		- Recibe por A la coordenada de la fila y por B la coordenada de la columna
*		- Devuelve el bit de Carry en 1 si se encuentrá por fuera del tablero
*			o en 0 si se encuentra dentro de los límites
*
**************************************************************************************************
inRange	equ	*

	%BACKUP
	
	cmpa	#$A		; Comparamos la primera coordenada con la mínima posible
	bmi	afuera		; Si es menor, salimos indicando que no pertenece a la matriz
	cmpa	#$F		; Comparamos la primera coordenada con la mayor posible
	bhi	afuera		; Si es mayor, salimos indicando que no pertenece a la matriz
	cmpb	#1		; Comparamos la segunda coordenada con la mínima posible
	bmi	afuera		; Si es menor, salimos indicando que no pertenece a la matriz
	cmpb	#6		; Comparamos la segunda coordenada con la máxima posible
	bhi	afuera		; Si es mayor, salimos indicando que no pertenece a la matriz
	bra	adentro		; Si no se cumplió ninguna de las condiciones anteriores, las coordenadas
*	...			; son correctas

*	Zona donde las coordenadas recibidas no son válidas
afuera	sec			; Seteamos el carry en 1 indicando que hubo error
	bra	endlim		; Salimos de la subrutina

*	Zona donde las coordenadas recibidas son válidas
adentro	clc			; Seteamos el carry en 0 indicando que no hubo error

endlim	%RESTORE
	rts



***************************************************************************************************************
*
*	testWin: Evalúa si uno de los jugadores ganó la partida, y en caso de ganar, procede a indicarlo en el 
*		 display y en el bitmap.
*		- Utiliza como parámetros las variables definidas al final del programa, que evalúan la cantidad
*			de barcos hundidos de cada jugador
*		- Devuelve el bit de Carry en 1 si hubo ganador, y en 0 si no hubo ganador aún.
*
***************************************************************************************************************
testWin	equ	*

	%BACKUP

	ldaa	canhun1
	cmpa	#CAN_BAR	; Comparo la cantidad de hundidos por los jugadores con #6 --> por ser el número de barcos 
	beq	win1		; con los que se juega
	ldaa	canhun2		; Si la cantidad de hundidos por el jugador 1 es 6, imprimimos la frase de felicitaciones al jugador 1
	cmpa	#CAN_BAR	; Si la cantidad de hundidos por el jugador 2 es 6,
	beq	win2		; Imprimimos la frase de felicitaciones al jugador 2
	clc			; ponemos el carry en 0 si ningún jugador ganó.
	bra	finwin		; Si ninguno de los jugadores alcanzó la cantidad de hundidos necesarios, salimos

win1	equ	*
	ldx	#winner1	; Cargamos en X la posición del primer caracter de la frase para el jugador 1
	jsr	displ		; Imprimimos la frase y salimos
	bra	fingana
	
win2	equ	*	
	ldx	#winner2	; Cargamos en X la posición del primer caracter de la frase para el jugador 2
	jsr	displ		; Imprimimos la frase y salimos

fingana	jsr	espiral		; Imprimimos un efecto de espiral en el bitmap mostrando el jugador que ganó la partida
	sec			; ponemos el carry en 1 indicando que un jugador ya ganó y salimos

again	jsr	waitkey		; analizamos el teclado, esperando un RESET
	cmpa	#RESET			
	bne	again		; de ser reset, volvemos a empezar de 0.
	
finwin	%RESTORE


	rts




*************************************************************************************************************
*
*	setTurn: cambia el turno al jugador correspondiente
*		- Recibe por AccA la tecla presionada
*		- Modifica la posición de memoria turno que contiene el turno actual.
*
**************************************************************************************************************
setTurn	equ	*

	%BACKUP

	ldab	turno		; analizamos de quién es el turno que apretó la tecla
	cmpb	#1
	bne	jug2
*_____________________
*
* Turno jugador 1
*____________________
jug1	ldab	shot_ID
	cmpb	#1
	beq	fire1		; analizamos si hubo un disparo previo errado
	cmpa	#P1_KEY		; analizo si la tecla apretada es P1_KEY
	beq	tec1		; si es, se vuelve a elegir el jugador 1
	bra	finturn		; si se apretó P2, salimos (no pasa nada)

fire1	cmpa	#P2		; si hubo disparo y se apretó P2
	beq	tec2		; cambiamos el turno al jugador 2
	bra	finturn		; en caso contrario, salimos (no se repite el turno de P1)
*____________________
*
* Turno jugador 2
*____________________
jug2	ldab	shot_ID
	cmpb	#1
	beq	fire2		; analizamos si hubo un disparo previo errado
	cmpa	#P2		; analizo si la tecla apretada es P2
	beq	tec2		; si es, se vuelve a elegir el jugador 2
	bra	finturn		; si se apretó P1_KEY, salimos (no pasa nada)

fire2	cmpa	#P1_KEY		; si hubo disparo y se apretó P1_KEY
	beq	tec1		; cambiamos el turno al jugador 1
	bra	finturn		; en caso contrario, salimos (no se repite el turno de P2)

*_______________________
*
* Cambio a jugador 1
*_______________________
tec1	ldaa	#1
	staa	turno		; Indico en una posición de memoria que es el turno del jugador 1
	ldx	#frase1		; mostramos la frase de jugador 1 en el display
	jsr	displ
	ldx	#play2		; cargamos en el bitmap el tablero del jugador 2
	bra	change
*_______________________
*
* Cambio a jugador 2
*_______________________
tec2	ldaa	#2
	staa	turno		; Indico en una posición de memoria que es el turno del jugador 2
	ldx	#frase2		; mostramos la frase de jugador 2
	jsr	displ
	ldx	#play1		; cargamos en el bitmap el tablero del jugador 1
*_______________________________________________________________________________
*
* Copiamos la matriz del jugador siguiente y borramos las coordenadas ingresadas
*________________________________________________________________________________
change	jsr	copiado
	clr	coor1
	clr	coor2
	clr	shot_ID

finturn	%RESTORE
	
	rts



	rseg	CONST

car_txt	fcc	'COLOQUE CARGUERO'
	fcb	0

sub_txt	fcc	'COLOQUE SUBMARINO'
	fcb	0

acz_txt	fcc	'COLOQUE ACORAZADO'
	fcb	0

gamebeg	fcc	'COMIENZA LA BATALLA'
	fcb	0

	END